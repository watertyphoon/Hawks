#include <NonBlockingGame.h>
#include <iostream>
#include <fstream>

using namespace bridges::game;

struct my_game : public NonBlockingGame {
  // defaults for background color, symbol color, symbol
  NamedColor defaultColor, cursorColor, altColor;
  int pixelNum, altNum;
 
  int static const rows = 16;
  int static const colums = 16;

  int cursorLoc[2];
  int gameBoard[rows][colums];

  /* Initializes the game, passing credentials to bridges
     
   */
  my_game(int assID, std::string username, std::string apikey)
    : NonBlockingGame (72, username, apikey, rows , colums) {
    setTitle("Pixel Drawing");
    setDescription("W: Load, S: Save, Arrow keys for Movement, Q: Switch pixel, Space: Place pixel");
  }

  /* Initialize from NonBlockingGame
     Called once at game start
     More info at https://bridgesuncc.github.io/doc/cxx-api/current/html/classbr     idges_1_1game_1_1_non_blocking_game.html
   */
  virtual void initialize() override {
    keyLeftSetupFire(2);
    keyUpSetupFire(2);
    keyDownSetupFire(2);
    keyRightSetupFire(2);
    keyQSetupFire(10);
    for(int i = 0; i < rows; i++) {
      for(int j = 0; j < colums; j++) {
	gameBoard[i][j] = 0;
      }
    }

    cursorLoc[0] = 0;
    cursorLoc[1] = 0;
    
    defaultColor = NamedColor::black;
    altColor = NamedColor::white;
    cursorColor = NamedColor::blue;
    pixelNum = 1;
    altNum = 0;

    updateGridColor();
    
  }

  // updates the visual board by changing the colors to match the gameBoard
  void updateGridColor() {
    for (int r = 0; r < rows; r++) {
      for (int c = 0; c < colums; c++) {
        if(gameBoard[r][c] == 0) {
          setBGColor(r, c, defaultColor);
        }
        else if(gameBoard[r][c] == 1) {
          setBGColor(r, c, altColor);
        }           
      }

      setBGColor(cursorLoc[0], cursorLoc[1], cursorColor);
    }
  }

  
 


  /* GameLoop from NonBlockingGame
     Called once each frame
     More info at https://bridgesuncc.github.io/doc/cxx-api/current/html/classbr     idges_1_1game_1_1_non_blocking_game.html
     Sets up key presses
   */
  virtual void gameLoop() override {
    
    if(keyUpFire() && cursorLoc[0] != 0) {
      cursorLoc[0]--;
    }
    else if(keyDownFire() && cursorLoc[0] != rows-1){
        cursorLoc[0]++;
    }
    if(keyLeftFire() && cursorLoc[1] != 0) {
      cursorLoc[1]--;
    }
    else if(keyRightFire() && cursorLoc[1] != (colums-1)){
      cursorLoc[1]++;
    }

    if(keySpace()) {
      gameBoard[cursorLoc[0]][cursorLoc[1]] = pixelNum;
    }
    if(keyQFire()) {
      changeCursor();
    }
    
    if(keyS()) {
      save();
    }
    if(keyW()) {
      load();
    }

    //UpdateBoard
    updateGridColor();


  }

  //Changes cursor back and forth from both colors
   void changeCursor() {
    int tempNum;
    
    tempNum = pixelNum;
    pixelNum = altNum;
    altNum = tempNum;
    
  }
  
  //Resets the position of the cursor
  void resetCursor() {
    cursorLoc[0] = 0;
    cursorLoc[1] = 0;
  }

  /* Saves the board to a txt file
     file must be specified
   */
  void save() {
    ofstream saveFile("savefile1.txt");
    if(saveFile.is_open()) {
      for(int r = 0; r < rows; r++){
	for(int c = 0; c < colums; c++) {
	  saveFile << gameBoard[r][c];
	}
	
      }

    }


  }

  /*Loads the board from a file
    file must be specified
   */
  void load() {
    ifstream loadFile("savefile1.txt");
    if(loadFile.is_open()) {
        for(int r = 0; r < rows; r++){
	  for(int c = 0; c < colums; c++) {
	    gameBoard[r][c] = loadFile.get() - '0';
	  }
	
	}
	resetCursor();
    }
  }
};


  

// Initialize your game
// Call your game class with your assignment id, username, and api key
int main (int argc, char** argv) {
  my_game g(72, "clarson9", "388334165483");

  g.start();
}
